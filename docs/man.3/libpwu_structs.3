.IX Title "STRUCTS 3
.TH STRUCTS 3 "June 2023" "libpwu 1.0" "structs"
.\" Automatically generated by Pandoc 3.1.2
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.hy
.SH data structures
.SS vector
.IP
.nf
\f[C]
typedef struct {
        
        byte * vector;
        size_t data_size;
        unsigned long length;

} vector;
\f[R]
.fi
.SS description
.PP
\f[V]vector\f[R] is this library\[cq]s vector implementation.
.SS elements
.IP \[bu] 2
\f[V]vector\f[R] : pointer to heap allocation holding the vector.
.IP \[bu] 2
\f[V]data_size\f[R] : size of each element.
.IP \[bu] 2
\f[V]length\f[R] : number of elements in the vector.
.SS functions
.IP \[bu] 2
\f[V]vector_get()\f[R]
.IP \[bu] 2
\f[V]vector_get_ref()\f[R]
.PP
.SS maps_entry
.IP
.nf
\f[C]
typedef struct {

        //read_maps()
        char pathname[PATH_MAX];
        char basename[NAME_MAX];
        byte perms;
        void * start_addr;
        void * end_addr;
        unsigned long obj_vector_index;

        //get_caves()
        vector cave_vector; //cave

} maps_entry;
\f[R]
.fi
.SS description
.PP
\f[V]maps_entry\f[R] represents a single line in a
\f[V]/proc/<pid>/maps\f[R] file for a single process, sorted into the
desired components.
Data specific to each segment is also stored here.
Created automatically.
.SS elements
.IP \[bu] 2
\f[V]pathname\f[R] : name of the backing file for this segment.
refer to \f[V]proc(5)\f[R].
.IP \[bu] 2
\f[V]basename\f[R] : basename of backing file for this segment.
refer to \f[V]proc(5)\f[R].
.IP \[bu] 2
\f[V]perms\f[R] : permissions for the region, see \f[V]mprotect(2)\f[R]
for format.
.IP \[bu] 2
\f[V]start_addr\f[R] : address of the start of this segment in
\f[V]/proc/<pid>/mem\f[R].
.IP \[bu] 2
\f[V]end_addr\f[R] : address of the end of this segment in
\f[V]/proc\[rs]<pid\[rs]>/mem\f[R].
.IP \[bu] 2
\f[V]object_vector_index\f[R] : index into
\f[V]maps_data.obj_vector\f[R] for this entry.
.IP \[bu] 2
\f[V]cave_vector\f[R] : vector of \f[V]cave\f[R] struct.
.SS functions
.IP \[bu] 2
\f[V]get_caves()\f[R]
.PP
.SS maps_obj
.IP
.nf
\f[C]
typedef struct {

        char pathname[PATH_MAX];
        char basename[NAME_MAX];
        vector entry_vector; //*maps_entry

} maps_obj;
\f[R]
.fi
.SS description
.PP
\f[V]maps_obj\f[R] is a `backing file'/pathname based view of
\f[V]map_entry\f[R] structures.
It holds the backing file and every segment that belongs to it.
See \f[V]proc(5)\f[R].
Created automatically.
.SS elements
.IP \[bu] 2
\f[V]name\f[R] : name of the backing file for this object.
.IP \[bu] 2
\f[V]basename\f[R] : basename of backing file for this object.
.IP \[bu] 2
\f[V]entry_vector\f[R] : vector of pointers to \f[V]maps_entry\f[R]
structures belonging to this backing file.
.SS functions
.PP
none.
.PP
.SS maps_data
.IP
.nf
\f[C]
typedef struct {

        vector obj_vector; //maps_obj
        vector entry_vector; //maps_entry

} maps_data;
\f[R]
.fi
.SS description
.PP
\f[V]maps_data\f[R] is the overarching data structure representing the
entire \f[V]/proc/<pid>/maps\f[R] file for a single process.
Requires initialisation.
Filled by \f[V]read_maps()\f[R].
.SS elements
.IP \[bu] 2
\f[V]obj_vector\f[R] : vector storing a backing file oriented view of
segments.
.IP \[bu] 2
\f[V]entry_vector\f[R] : vector storing segments as they appear in
\f[V]/proc/<pid>/maps\f[R].
.SS functions
.IP \[bu] 2
\f[V]new_maps_data()\f[R]
.IP \[bu] 2
\f[V]del_maps_data()\f[R]
.IP \[bu] 2
\f[V]read_maps()\f[R]
.PP
.SS pattern
.IP
.nf
\f[C]
typedef struct {

    maps_entry * search_region;
    byte pattern_bytes[PATTERN_LEN];
    int pattern_len;
    vector offset_vector;

} pattern;
\f[R]
.fi
.SS description
.PP
\f[V]pattern\f[R] contains members related to performing a byte pattern
search on a memory segment.
Requires initialisation.
.SS elements
.IP \[bu] 2
\f[V]search_region\f[R] : segment to carry out the search on.
.IP \[bu] 2
\f[V]pattern_bytes\f[R] : pattern of bytes to search for.
.IP \[bu] 2
\f[V]pattern_len\f[R] : length of the pattern of bytes to search for.
.IP \[bu] 2
\f[V]offset_vector\f[R] : vector of offsets at which the pattern occurs
(first byte).
.SS functions
.IP \[bu] 2
\f[V]new_pattern()\f[R]
.IP \[bu] 2
\f[V]del_pattern()\f[R]
.IP \[bu] 2
\f[V]match_pattern()\f[R]
.PP
.SS cave
.IP
.nf
\f[C]
typedef struct {

    unsigned int offset;
    int size;

} cave;
\f[R]
.fi
.SS description
.PP
\f[V]cave\f[R] stores data about areas of unused memory where payloads
may be injected.
Created automatically inside \f[V]maps_entry\f[R] by
\f[V]get_caves()\f[R].
.SS elements
.IP \[bu] 2
\f[V]offset\f[R] : offset at which the cave begins (first byte).
.IP \[bu] 2
\f[V]size\f[R] : size of the cave, in bytes.
.SS functions
.IP \[bu] 2
\f[V]get_caves()\f[R]
.PP
.SS raw_injection
.IP
.nf
\f[C]
typedef struct {

    maps_entry * target_region;
    unsigned int offset;

    byte * payload;
    unsigned int payload_size;

} raw_injection;
\f[R]
.fi
.SS description
.PP
\f[V]raw_injection\f[R] stores data for injecting a payload at an
arbitrary offset inside a region.
Requires initialisation.
.SS elements
.IP \[bu] 2
\f[V]target_region\f[R] : \f[V]maps_entry\f[R] segment where the
injection will take place.
.IP \[bu] 2
\f[V]offset\f[R] : offset at which to begin injection (first byte).
.IP \[bu] 2
\f[V]payload\f[R] : pointer to heap allocated space holding the payload.
.IP \[bu] 2
\f[V]payload_size\f[R] : size of the payload on the heap in bytes.
.SS functions
.IP \[bu] 2
\f[V]new_raw_injection()\f[R]
.IP \[bu] 2
\f[V]del_raw_injection()\f[R]
.IP \[bu] 2
\f[V]raw_inject()\f[R]
.PP
.SS rel_jump_hook
.IP
.nf
\f[C]
typedef struct {

    maps_entry * from_region;
    uint32_t from_offset; //address of jump instruction

    maps_entry * to_region;
    uint32_t to_offset;

} rel_jump_hook;
\f[R]
.fi
.SS description
.PP
\f[V]rel_jump_hook\f[R] stores data for hooking an existing 4 byte
relative jump and changing the offset to jump to another location.
Set manually.
.SS elements
.IP \[bu] 2
\f[V]from_region\f[R] : \f[V]maps_entry\f[R] segment where the target
relative jump is located.
.IP \[bu] 2
\f[V]from_offset\f[R] : offset at which the relative jump begins (first
byte).
.IP \[bu] 2
\f[V]to_region\f[R] : \f[V]maps_entry\f[R] segment where the target
relative jump will now jump to.
.IP \[bu] 2
\f[V]to_offset\f[R] : offset to which the target relative jump will now
jump to inside the \f[V]to_region\f[R] segment.
.SS functions
.IP \[bu] 2
\f[V]hook_rj()\f[R]
.PP
.SS name_pid
.IP
.nf
\f[C]
typedef struct {

    char name[NAME_MAX];
    vector pid_vector; //pid_t

} name_pid;
\f[R]
.fi
.SS description
.PP
\f[V]name_pid\f[R] stores the name of a target process and a vector of
all processes that match this name.
\f[V]pid_vector\f[R] is populated by \f[V]pid_by_name()\f[R].
Requires initialisation.
.SS elements
.IP \[bu] 2
\f[V]name\f[R] : name of the target process
.IP \[bu] 2
\f[V]pid_vector\f[R] : vector of process IDs that match \f[V]name\f[R].
.SS functions
.IP \[bu] 2
\f[V]new_name_pid()\f[R]
.IP \[bu] 2
\f[V]del_name_pid()\f[R]
.IP \[bu] 2
\f[V]pid_by_name()\f[R]
.PP
.SS puppet_info
.IP
.nf
\f[C]
typedef struct {

    pid_t pid;

    void * syscall_addr;

    struct user_regs_struct saved_state;
    struct user_fpregs_struct saved_float_state;

    struct user_regs_struct new_state;
    struct user_fpregs_struct new_float_state;

} puppet_info;
\f[R]
.fi
.SS description
.PP
\f[V]puppet_info\f[R] stores data required to attach to a process and
change the permissions of its segments.
Set \f[V]pid\f[R] manually, the rest is for internal use.
.SS elements
.IP \[bu] 2
\f[V]pid\f[R] : target process ID.
.IP \[bu] 2
\f[V]*syscall_addr\f[R] : syscall instruction address in executable
memory of puppet.
.IP \[bu] 2
\f[V]saved_state\f[R] : registers at time of puppet.
.IP \[bu] 2
\f[V]saved_float_state\f[R] : floating point registers at time of
puppet.
.IP \[bu] 2
\f[V]new_state\f[R] : registers for \f[V]mprotect\f[R] syscall.
.IP \[bu] 2
\f[V]new_float_state\f[R] : floating point registers for
\f[V]mprotect\f[R] call.
.SS functions
.IP \[bu] 2
\f[V]puppet_attach()\f[R]
.IP \[bu] 2
\f[V]puppet_detach()\f[R]
.IP \[bu] 2
\f[V]puppet_find_syscall()\f[R]
.IP \[bu] 2
\f[V]puppet_save_regs()\f[R]
.IP \[bu] 2
\f[V]puppet_write_regs()\f[R]
.IP \[bu] 2
\f[V]puppet_copy_regs()\f[R]
.IP \[bu] 2
\f[V]change_region_perms()\f[R]
.PP
.SS new_thread_setup
.IP
.nf
\f[C]
typedef struct {

    maps_entry * thread_func_region;
    maps_entry * setup_region;
    unsigned int thread_func_offset;
    unsigned int setup_offset;
    void * stack_addr;
    unsigned int stack_size;

} new_thread_setup;
\f[R]
.fi
.SS description
.PP
\f[V]new_thread_setup\f[R] contains data needed to create a new thread
inside the target process.
\f[V]stack_addr\f[R] must be initialised with
\f[V]create_thread_stack()\f[R].
\f[V]thread_func_region\f[R] and \f[V]thread_func_offset\f[R] must be
set manually.
.SS elements
.IP \[bu] 2
\f[V]thread_func_region\f[R] : segment where the thread function
resides, set manually.
.IP \[bu] 2
\f[V]setup_region\f[R] : segment where the setup payload will be
injected, set manually.
.IP \[bu] 2
\f[V]thread_func_offset\f[R] : offset for the thread function in its
segment, set manually.
.IP \[bu] 2
\f[V]setup_offset\f[R] : offset to inject at inside the setup segment,
set manually.
.IP \[bu] 2
\f[V]stack_addr\f[R] : new thread stack, set by
\f[V]create_thread_stack()\f[R]
.IP \[bu] 2
\f[V]stack_size\f[R] : stack size, set manually prior to
\f[V]create_thread_stack()\f[R]
.SS functions
.IP \[bu] 2
\f[V]create_thread_stack()\f[R]
.IP \[bu] 2
\f[V]start_thread()\f[R]
.PP
.SS mutation
.IP
.nf
\f[C]
typedef struct {

    unsigned int offset;
    byte mod[32];
    int mod_len;

} mutation;
\f[R]
.fi
.SS description
.PP
\f[V]mutation\f[R] is a single mutation applied to a payload by the
\f[V]apply_mutations()\f[R] function, which takes a vector of
\f[V]mutation\f[R] structures.
.SS elements
.IP \[bu] 2
\f[V]offset\f[R] : offset into the payload at which to begin the
mutation.
.IP \[bu] 2
\f[V]mod[32]\f[R] : buffer holding the mutation, up to 32bytes in size;
.IP \[bu] 2
\f[V]mod_len\f[R] : the real length of the mutation stored in
\f[V]mod[32]\f[R].
.SS functions
.IP \[bu] 2
\f[V]apply_mutations()\f[R]
.PP
.SS sym_resolve
.IP
.nf
\f[C]
typedef struct {

    void * lib_handle;
    maps_data * host_m_data;
    maps_data * target_m_data;

} sym_resolve;
\f[R]
.fi
.SS description
.PP
\f[V]sym_resolve\f[R] stores data for resolving shared object symbols in
the target process.
.SS elements
.IP \[bu] 2
\f[V]*lib_handle\f[R] : shared object handle returned by
\f[V]open_lib()\f[R].
.IP \[bu] 2
\f[V]*host_m_data\f[R] : own process process maps, populate manually.
.IP \[bu] 2
\f[V]*target_m_data\f[R] : target process maps, populate manually.
.SS functions
.IP \[bu] 2
\f[V]open_lib()\f[R]
.IP \[bu] 2
\f[V]close_lib()\f[R]
.IP \[bu] 2
\f[V]get_symbol_addr()\f[R]
.IP \[bu] 2
\f[V]resolve_symbol()\f[R]
